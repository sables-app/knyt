import { ensureReference, type Reference } from "@knyt/artisan";
import type { PluginBuilder } from "bun";

import { isDependencyInjectionEnabled } from "./RequestState/mod";
import type { GlazierPluginOptions, TransformResult } from "./transform/mod";
import { VirtualModuleManager } from "./VirtualModuleManager";

function renderDependenciesScriptContents(
  rendererModulePaths: string[],
): string {
  const importStatements: string[] = [];
  const usageStatements: string[] = [];

  let moduleCount = 0;

  for (const modulePath of rendererModulePaths) {
    const defaultImportName = `r${moduleCount}`;

    importStatements.push(`import ${defaultImportName} from "${modulePath}";`);

    // Add a no-op reference to prevent the module from being tree-shaken away.
    usageStatements.push(`void ${defaultImportName};`);

    moduleCount++;
  }

  const contents = [
    `// This module is generated by @knyt/glazier.`,
    "\n",
    ...importStatements,
    "\n",
    ...usageStatements,
  ].join("\n");

  return contents;
}

export class DependencyManager {
  #virtualModules: VirtualModuleManager;

  readonly #options$: Reference.Readonly<DependencyManager.Options | null>;

  get #debug() {
    return this.#options$.value?.debug ?? false;
  }

  #log(...args: any[]): void {
    if (this.#debug) {
      console.debug(...args);
    }
  }

  constructor(options: Reference.Maybe<DependencyManager.Options>) {
    this.#options$ = ensureReference(options);
    this.#virtualModules = new VirtualModuleManager(options);
  }

  connect(builder: PluginBuilder): void {
    this.#virtualModules.connect(builder);
  }

  /**
   * Generates a virtual module that imports the given renderer modules,
   * and returns the virtual path of the generated module.
   */
  async #createPageScript(rendererModulePaths: string[]): Promise<string> {
    const { virtualPath } = await this.#virtualModules.addModule(
      renderDependenciesScriptContents(rendererModulePaths),
      "js",
    );

    return virtualPath;
  }

  /**
   * Injects a script tag into the HTML to load the renderer modules.
   *
   * @remarks
   *
   * The script tag is injected at the end of the <head> or <body> tag.
   * If neither tag is found, the script tag is appended to the end of the HTML.
   */
  async inject(transformResult: TransformResult): Promise<string> {
    const { html, rendererModulePaths, request } = transformResult;
    const hasDependencies = rendererModulePaths.length > 0;

    if (!hasDependencies || !isDependencyInjectionEnabled(request)) {
      return html;
    }

    const scriptPath = await this.#createPageScript(rendererModulePaths);
    const scriptTag = `<script type="module" src="${scriptPath}"></script>`;

    if (html.includes("</head>")) {
      return html.replace("</head>", `${scriptTag}</head>`);
    }
    if (html.includes("</body>")) {
      return html.replace("</body>", `${scriptTag}</body>`);
    }

    return `${html}\n${scriptTag}`;
  }
}

export namespace DependencyManager {
  export type Options = GlazierPluginOptions.Mutable;
}
