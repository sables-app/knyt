import path from "node:path";

import { ensureReference, type Reference } from "@knyt/artisan";
import type { PluginBuilder } from "bun";

import { relativePathWithDotSlash } from "./relativePathWithDotSlash";
import { isDependencyInjectionEnabled } from "./RequestState/mod";
import type { GlazierPluginOptions, TransformResult } from "./transform/mod";
import { VirtualModuleManager } from "./VirtualModuleManager";

function renderDependenciesScriptContents(
  rendererModulePaths: string[],
): string {
  const importStatements: string[] = [];
  const usageStatements: string[] = [];

  for (let i = 0; i < rendererModulePaths.length; i++) {
    const modulePath = rendererModulePaths[i];
    const defaultImportName = `r${i}`;

    importStatements.push(`import ${defaultImportName} from "${modulePath}";`);

    // Add a no-op reference to prevent the module from being tree-shaken away.
    usageStatements.push(`void ${defaultImportName};`);
  }

  const contents = [
    `// This module is generated by @knyt/glazier.`,
    "\n",
    ...importStatements,
    "\n",
    ...usageStatements,
  ].join("\n");

  return contents;
}

export class DependencyManager {
  #virtualModules: VirtualModuleManager;

  readonly #options$: Reference.Readonly<DependencyManager.Options | null>;

  get #debug() {
    return this.#options$.value?.debug ?? false;
  }

  #log(...args: any[]): void {
    if (this.#debug) {
      console.debug(...args);
    }
  }

  constructor(options: Reference.Maybe<DependencyManager.Options>) {
    this.#options$ = ensureReference(options);
    this.#virtualModules = new VirtualModuleManager(options);
  }

  connect(builder: PluginBuilder): void {
    this.#virtualModules.connect(builder);
  }

  /**
   * Generates a virtual module that imports the given renderer modules,
   * and returns the virtual path of the generated module.
   */
  async #createPageScript(
    inputPath: string,
    rendererModulePaths: string[],
  ): Promise<string> {
    const contents = renderDependenciesScriptContents(rendererModulePaths);
    const virtualModule = await this.#virtualModules.addModule(contents, "js");

    /**
     * Decide whether to use the virtual path or cached file path.
     *
     * Virtual paths are faster, but Bun's static server cannot resolve them
     * when HMR is enabled. In production (no HMR), use the virtual path.
     * In development (with HMR), use the cached file path.
     *
     * This is a temporary workaround until Bun supports virtual modules
     * natively or its static server can resolve them with HMR enabled.
     */
    const shouldUseVirtualPath = import.meta.env.NODE_ENV === "production";

    if (shouldUseVirtualPath) {
      return virtualModule.virtualPath;
    }

    await this.#virtualModules.ensureVirtualModuleCache(virtualModule);

    return relativePathWithDotSlash(
      path.dirname(inputPath),
      virtualModule.cachePath,
    );
  }

  /**
   * Injects a script tag into the HTML to load the renderer modules.
   *
   * @remarks
   *
   * The script tag is injected at the end of the <head> or <body> tag.
   * If neither tag is found, the script tag is appended to the end of the HTML.
   */
  async inject(transformResult: TransformResult): Promise<string> {
    const { html, inputPath, rendererModulePaths, request } = transformResult;

    if (!isDependencyInjectionEnabled(request)) {
      return html;
    }

    const hasDependencies = rendererModulePaths.length > 0;

    const scriptPaths = [];

    if (hasDependencies) {
      scriptPaths.push(
        await this.#createPageScript(inputPath, rendererModulePaths),
      );
    }

    const scriptTags = scriptPaths
      .map(
        (scriptPath) => `<script type="module" src="${scriptPath}"></script>`,
      )
      .join("\n");

    if (html.includes("</head>")) {
      return html.replace("</head>", `${scriptTags}</head>`);
    }
    if (html.includes("</body>")) {
      return html.replace("</body>", `${scriptTags}</body>`);
    }

    return `${html}\n${scriptTags}`;
  }
}

export namespace DependencyManager {
  export type Options = GlazierPluginOptions.Mutable;
}
