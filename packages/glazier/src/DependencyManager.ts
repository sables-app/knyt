import { ensureReference, type Reference } from "@knyt/artisan";
import type { PluginBuilder } from "bun";

import { isDependencyInjectionEnabled } from "./RequestState/mod";
import type { GlazierPluginOptions, TransformResult } from "./transform/mod";
import { VirtualModuleManager } from "./VirtualModuleManager";

function renderDependenciesScriptContents(
  rendererModulePaths: string[],
): string {
  const importStatements: string[] = [];
  const usageStatements: string[] = [];

  let moduleCount = 0;

  for (const modulePath of rendererModulePaths) {
    const defaultImportName = `r${moduleCount}`;

    importStatements.push(`import ${defaultImportName} from "${modulePath}";`);

    // Add a no-op reference to prevent the module from being tree-shaken away.
    usageStatements.push(`void ${defaultImportName};`);

    moduleCount++;
  }

  const contents = [
    `// This module is generated by @knyt/glazier.`,
    "\n",
    ...importStatements,
    "\n",
    ...usageStatements,
  ].join("\n");

  return contents;
}

export class DependencyManager {
  #virtualModules: VirtualModuleManager;

  readonly #options$: Reference.Readonly<DependencyManager.Options | null>;

  get #debug() {
    return this.#options$.value?.debug ?? false;
  }

  #log(...args: any[]): void {
    if (this.#debug) {
      console.debug(...args);
    }
  }

  constructor(options: Reference.Maybe<DependencyManager.Options>) {
    this.#options$ = ensureReference(options);
    this.#virtualModules = new VirtualModuleManager(options);
  }

  connect(builder: PluginBuilder): void {
    this.#virtualModules.connect(builder);
  }

  /**
   * Generates a virtual module that imports the given renderer modules,
   * and returns the virtual path of the generated module.
   */
  async #createPageScript(rendererModulePaths: string[]): Promise<string> {
    const { virtualPath } = await this.#virtualModules.addModule(
      renderDependenciesScriptContents(rendererModulePaths),
      "js",
    );

    return virtualPath;
  }

  /**
   * Injects a script tag into the HTML to load the renderer modules.
   *
   * @remarks
   *
   * The script tag is injected at the end of the <head> or <body> tag.
   * If neither tag is found, the script tag is appended to the end of the HTML.
   */
  async inject(transformResult: TransformResult): Promise<string> {
    const { html, rendererModulePaths, request } = transformResult;

    if (!isDependencyInjectionEnabled(request)) {
      return html;
    }

    const hasDependencies = rendererModulePaths.length > 0;
    // TODO: Determine if HMR is enabled in the relevant Bun server(s).
    // This may not be possible to do without monkey-patching Bun.
    // For now, we assume HMR is enabled in non-production environments.
    const shouldInjectHmr = import.meta.env.NODE_ENV !== "production";
    const scriptPaths = [];

    if (shouldInjectHmr) {
      // In development mode, include the HMR runtime for Glazier.
      // This enables hot updates for composed Knyt elements.
      // Otherwise, errors will occur when modules containing
      // Knyt elements are hot reloaded.
      scriptPaths.push("@knyt/glazier/_hmr/runtime");
    }
    if (hasDependencies) {
      scriptPaths.push(await this.#createPageScript(rendererModulePaths));
    }

    const scriptTags = scriptPaths
      .map(
        (scriptPath) => `<script type="module" src="${scriptPath}"></script>`,
      )
      .join("\n");

    if (html.includes("</head>")) {
      return html.replace("</head>", `${scriptTags}</head>`);
    }
    if (html.includes("</body>")) {
      return html.replace("</body>", `${scriptTags}</body>`);
    }

    return `${html}\n${scriptTags}`;
  }
}

export namespace DependencyManager {
  export type Options = GlazierPluginOptions.Mutable;
}
